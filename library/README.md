# Coding Test

```
입력 예시
첫째 줄에 지도의 세로 크기 N과 M이 주어진다. (3<= N, M <= 8)
둘째 줄부터 N개의 줄에 지도 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다.
2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.
빈 칸의 개수는 3개 이상이다.
```
1. 최대 최소 범위를 파악합니다.
2. 단순 구현이라면 구현하자.
3. 무식하게 풀 수 있다면 무식하게 풀자.
4. 아니라면 다른 알고리즘을 생각하자.
5. 제출하기 전, 반례를 항상 생각하자.


## 입력 제한을 고려한 알고리즘

O(f(n)) : n 이 충분히 커지면 소요시간이 c x f(n) 보다 작거나 같다.

빅-오 표기법은 각 알고리즘이 입력 n에 따라 가장 많은 연산을 할 경우,
점근적으로 어느정도 시간이 걸리는지 추정하는 방식입니다.

1~n 까지 하나하나 더하는 알고리즘은 최악일 때 n에 비례해서 소요시간이 걸린다.
&rarr; O(n)

2중 루프는 O(n^2) 이다.
알고리즘이 쓴 자료구조를 종합해서 계산하기도 한다. (Heap, Queue, Tree etc.)

## 입력 제한

코딩 테스트에는 입력 제한이 있다. 
입력 제한을 보고 이 문제가 뚫리는 빅-오 노테이션을 추정할 수 있다.

### n<=20 이면 웬만한 저질 구현도 통과된다. 

```
n = 20
O(2^n)  = 1048576
10^8 = 1초 이내
```

O(n!), O(2^n) 등이 이에 해당한다.
최적화 없이 모든 경우의 수를 세는 기법
`빡구현` 혹은 `브루트 포스`, `전탐색`이라고 한다.

***

### n <=100 이면 적당한 삼중 루프가 통과된다.

```
n=100
O(n^3) = 10^6
10^8 = 1초 이내
```

**플로이드-와샬 알고리즘**
그래프에서 모든 점들 간의 최단 거리를 구하는 알고리즘

***

### n<=1000 이면 적당한 이중 루프가 통과된다.

```
n=1000
O(n^2) = 10^6
10^8 = 1초 이내
```

**벨만 포드 알고리즘**
거리에 음수가 있는 그래프에서 한 점과 나머지 점들의 최단 거리를 구하는 알고리즘

***

### n<=10000 이면 머리를 좀 써야 한다.

```
n=10000
O(n) = 10000
O(nlogn) = 40000
10^8 = 1초 이내
```

**동적 프로그래밍**
큰 문제를 작은 문제로 쪼개고, 작은 문제의 답을 메모하여 문제를 푸는 기법

**이분 탐색**
탐색 범위를 절반씩 줄여가며 해답을 찾는 기법

**다익스트라 알고리즘**
거리가 모두 양수인 그래프에서 한 지점과 다른 모든 지점까지의 최단 거리를 찾는 알고리즘

**유니언 파인드**
원소들을 서로 겹치지 않는 집합에 묶고 병합하는 알고리즘과 자료구조

**세그먼트 트리**
구간별 합이나 곱을 효과적으로 저장하는 트리 자료구조

**투 포인터**
1차원 배열에서 두 인덱스를 저장하여 O(n)으로 계산하는 기법

***

### n<=10^8 이면 수학적 기믹이 필요하다.

```
n = 10^8
O(logn) = 8
10^8 = 1초 이내
```

**유클리드 호제법**
두 자연수를 서로 나누어 최대 공약수를 빠르게 구하는 기법